타입스크립트!!!!!
2012년에 발표 대규모 javascript 애플리케이션 개발
microsoft오픈소스 프로그래밍 언어
-자바스크립트의 상위 집합
-자바스크립트를 사용, 모든 기능 포함
-자바스크립트에 포함되지 않는 새로운 기능
-정적인 언어
*자바스크립트와 가장 큰 차이!!!!!!
자바스크립트는 동적인 언어이며 프로그램 구동 중에 타입이 다이나믹하게 변경되나 타입스크립트는 정적인언어이며
프로그램을 작성할 때 타입을 정의함


웹브라우져가 해석할수 있는 언어
html, css, javascript
typtescript



//////////////////////////////////////////
this 바인딩 메소드
this ====> window
user.print()

함수호출에서 사용할 this를 바인딩(지정)
function pringName(){
	console.log(this.name);
}

printName()




call()
apply()
함수 매개변수를 처리하는 방법을 제외하면 call과 동일함
call은 일반적인 함수와 같이 매개변수를 직접받지만 apply배열로 받는다!!!!
update.call(green, 1998, "teacher")
update.apply(green, [1998, "teacher"])

bind()
함수에서 사용할 this 영구적으로 지정
사용방법
const updatebella = 함수.bind(this 대상객체)
updatebella(1980, "police");


/////
Enum 열거형 타입
숫자 혹은 문자열 값 집합에 이름을 부여할 수 있는 타입
값의 종류가 일정한 범위로 정해져 있는 경우 유용함.
구문 enum name {
	값1,
	값2,
	값3
	}


interface 타입스크립트의 여러 객체를 정의하는 일종의 규칙이며 구조이다

1. 객체의 타입정의
객체타입의 interface
interface 인터페이스이름 {
	readonly key:key 타입;
	key?: key타입
}
2. 함수의 타입정의
함수타입의 interface
interface 인터페이스 이름{
	호출 시그니쳐 정의
	(parameter: paremetertype): return type
}
3. 클래스의 타입정의



====================================2/17
함수 오버로드
이름은 같고 매개변수 타입과 반환타입이 다른 여러 함수를 만들 수 있음
다양한 구조의 함수를 생성하고 관리할 수 있음

선언부
function add(a:string, b: string): string;
function add(a:number, b:number): number;
function add(a: any, b: any) : any{
	return a + b;
}

구현부


===========================이부분은 꼭 기억해줄것
함수

function add(a,b){
	return a +b
}

리턴타입 지정시 리턴이 없는 경우 void
function add(a: number, b: number) : number {
	return a + b
} 
let add: (a:number, b: number) => number;
add = function(a,b){
	return a + b
}

add = (a,b) => {return a + b}
===================================
볷븝
함수에서 사용할 this를 지정
function printuser(age, isjob){
	console.log(this.name)
}

green = {name: "green", age: 30}
printuser.call(green, 30, true);
printuser.apply(green,[30,true]);
const fn = printuser.bind(green)
fn(30,true)


call()
apply()
bind()



//////////////
Generic 제네릭
재사용을 목적으로 함수나 클래스의 선언 시점이 아닌 사용 시점에 타입을 선언
타입을 인수로 받아서 사용

타입변수는 사용자가 제공한 타입으로 변환될 식별자이다

function getSize(arr:number [] | string [] | boolean [] | object []): number{
	return arr.length;
}
const arr1 = [1,2,3];
getSize(arr1) // 3

const arr2 = ["a", "b", "c", "b"]
getSize(arr2) //

const arr3 = [false, true ,true, false]
getSize(arr3)

const arr4 = [{},{name:"g"},{},{},{}]
getSize(arr4)


이렇게 타입이 하나씩 추가될때마다 함수 유니언타입으로 하나씩 타입을 추가해줘야함
이렇게 귀찮음을 방지해주는게 제네릭!!!!!!!
//위 아래 비교
<T>이거는 타입변수라고 부름

function getSize<T>(arr: T[]): number{
	return arr.length;
}

const arr1 = [1,2,3];
getSize<number>(arr1) // 3

const arr2 = ["a", "b", "c", "b"]
getSize<string>(arr2) //

const arr3 = [false, true ,true, false]
getSize<boolean>(arr3)

const arr4 = [{},{name:"g"},{},{},{}]
getSize<object>(arr4)
//

제네릭 제약조건(타입에 제약조건을 준거임)
T extends U
ex> T string 과 number만 허용 하겠다
<T extends number | string>
<T extends {name: string}>
interface Mytype<T> {
	name: string;
	value: T
}

const data: Mytype<number> = {
	name: "A",
	value: 123
}

const data: Mytype<string> = {
	name: "A",
	value: "aaa"
}

const data: Mytype<boolean> = {
	name: "A",
	value: true
}
=========================================
interface에 원하는 타입만 오게하고싶을때 extends 사용

interface Mytype<T extends number | string> {
	name: string;
	value: T
}

const data: Mytype<number> = {
	name: "A",
	value: 123
}

const data: Mytype<string> = {
	name: "A",
	value: "aaa"
}

const data: Mytype<boolean> = {  xxxxxx 이타입은 못옴
	name: "A",
	value: true
}

방법 2 타입 변수에 할당 
type U = string | number | boolean

interface Mytype<T extends U> {
	name: string;
	value: T
}

const data: Mytype<number> = {
	name: "A",
	value: 123
}

const data: Mytype<string> = {
	name: "A",
	value: "aaa"
}

const data: Mytype<boolean> = {  
	name: "A",
	value: true
}

=============
새로운 interface 3개 생성 ----->
새로운 interface 타입의 객체를 3개 생성
printColor()함수 구현 ----> 객체타입을 매개변수로 받아서
객체.color를 콘솔에 출력해줌

interface changmin1 {
    name: string
    color: string
}

interface changmin2 {
    name: string
    color: string
}

interface changmin3 {
    name: string
}

const chang1: changmin1 = {
    name: "창민",
    color: "흰색"
}

const chang2: changmin2 = {
    name: "창민1",
    color: "블루"
   
}

const chang3: changmin3 = {
    name: "창민2",
}


function printColor<T>(data: T) {    여기서 콘솔창에 필요한 값을 주기위해서 아래 함수처럼 수정해야함
    console.log(data.color)
}

function printColor<T extends {color: String}>(data: T) {  칼라 데이터가 필요하기때문에 extends {color: String} //// String 소문자 쓰면 안됨
    console.log(data.color)
}

printColor(chang1)
printColor(chang2)
//printColor(chang3) //프로퍼티가 없어서 에러 발생

//////////////////////
인터페이스 확장(상속받기) -- 위에는 제약조건임
interface IAnimal {
	name: string
}

interface ICat extends IAnimal {
	sound(): string
}

class Cat implements ICat {
	name: string;
	constructor(name){
		this.name = name;
	}
	sound(){
		return "야옹"
	}
}
같은 이름의 interface 를 여러개 만들 수 있음.
기존에 만들어진 interface에 내용을 추가하는 경우 유용함

interface IName {
	name1: string;
	age: number
}

interface iName {
	name2: string;
}

const namename: IName = {
	name1: "A",
	age: 20,
	name2: "B"
}

////////////////////////////

클래스
class Cat {
	constructor(name, age){
		this.name = name;     //여기를 필드라고 함
		this.age = age;
	}
	sound() {
		console.log("야옹")
	}
}

클래스는 필드와 메소드로 구성되있다
접근제한자 
public: 
의미: 어디서나 자유롭게 접근가능(생략가능) 
클래스 내부에서 접근, 인스턴스 접근가능, 자식 클래스에서도 접근가능
범위: 속성, 메소드

protected(보호)
의미 -> 내 클래스 내부, 자식 클래스 내부에서 접근가능 (인스턴스 접근 안됨)
범위 -> 속성, 메소드

private(사적인)
의미 -> 내 클래스 내부에서 접근가능(자식클래스 접근안됨, 인스턴스 접근 안됨)


클래스 ---> 객체(인스턴스)
타입스크립트 클래스

class Animal {
	kind: string
	constructor(kind){
		this.kind = kind;
	}
}


class Cat extends Animal {
	public name: string;
	public age: number
	constructor(name, age, kind){
.
		super(kind)
		this.name = name;     //여기를 필드라고 함
		this.age = age;
	}
	public printName(){
		console.log(this.name)
		this.sound();
	}
	public sound() {
		console.log("야옹")
	}
}
//클래스를 만든 객체를 인스턴스라고함
const cat1 = new Cat("레오", 4);
인스턴스에서 접근
cat1.sound()
cat1.name
필드, 메소드

정적 멤버  -- 정적 필드, 정적 메소드  static붙이면 정적 멤버임(객체 접근불가)
인스턴스 멤버 - 인스턴스 필드, 인스턴스 메소드


클래스 필드, 메소드

클래스 ---> 객체(클래스의 인스턴스)  --->인스턴스 멤버
접근방법은
let cat = new Cat("레오")
cat.name 는 인스턴스 멤버임

클래스 ---> 정적 멤버
정적멤버 접근 방법은
ClassCat.name2

사용 키워드 abstract 키워드
추상클래스
추상클래스는 상속만 가능하고 인스턴스(객체)를 생성할수 없다

추상메소드
메소드의 이름만 선언하고 구체적인 기능은 상속받는 쪽에서 구현한다.
상속받는 클래스는 모두 다 같은 이름의 메소드를 가지며
구현은 각각 다르게 할 수 있다.

abstract class Person {
	name: string;
	construtor(name){
		this.name = name;
	}
	abstract work(): void;
}

class Teacher extends Person {
	work():void {
		console.log("가르키는 일을 합니다")
	}
}

class Engineer extends Person {
	work():void{
		console.log("가르키는 일을 합니다"
	}
}

const person1 = new Person() 는 생성(사용) 불가